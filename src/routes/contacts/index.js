import { Component } from 'preact';
import { observer } from 'preact-mobx';
import List from 'preact-material-components/List';
import Dialog from 'preact-material-components/Dialog';
import TextField from 'preact-material-components/TextField';
import 'preact-material-components/TextField/style.css';
import 'preact-material-components/List/style.css';
import 'preact-material-components/Button/style.css';
import 'preact-material-components/Dialog/style.css';
import style from './style.css';
import firebase, { firestore } from '../../state/firebase';

@observer
export default class ContactsList extends Component {

	inviteContact(e) {
		e.preventDefault();
		const contactEmail = document.querySelector('#email-field').value;
		document.querySelector('#email-field').value = null;

		// todo: validate email more throroughly
		if (contactEmail == firebase.auth().currentUser.email) return;

		// todo - maybe use transaction(s) somewhere in here?
		// check if this contact has already been invited, todo - check in a cached list of emails in state/ later
		firestore.collection('users/' + firebase.auth().currentUser.uid + '/outgoing_invitations')
			.where('email', '==', contactEmail)
			.get()
			.then(snapshot => {
					if (snapshot.empty) this.inviteContactHelper(contactEmail);
					else console.log('contact has already been invited');
				}
			)
	}

	inviteContactHelper(contactEmail) {
		let contactSnapshot;

		// todo - maybe use transaction(s) somewhere in here?
		// query firestore for user with contactEmail
		firestore.collection('users').where('email', '==', contactEmail)
			.get()
			.then(snapshot => {
					if(!snapshot.empty) {
						contactSnapshot = snapshot.docs[0];
						console.log('user_: ', contactSnapshot);
					}
				}
			)
			.then(() => {
				// if no such user, lookup email in future_users
				if(!contactSnapshot) {
					return firestore.collection('future_users').where('email', '==', contactEmail)
						.get()
						.then(
							snapshot => {
								if(!snapshot.empty) {
									contactSnapshot = snapshot.docs[0];
									console.log('future_user_: ', contactSnapshot);
								}
							}
						);
				}
			})
			.then(() => {
				// if no such future_user, create future_user doc
				if(!contactSnapshot) {
					// todo - presumably I could make this block less confusing?
					const futureUserRef = firestore.collection('future_users').doc();
					return futureUserRef.set({email: contactEmail})
						.then(() => {
							futureUserRef.get()
								.then(futureUserSnapshot => {
									contactSnapshot = futureUserSnapshot;
									console.log('new_future_user_: ', contactSnapshot);
								});
						})
						.catch(err => {
							console.error('Error adding future_user: ', err);
							throw err;
							// todo - this is presumably the type of thing a transaction would be useful for
						});
				}
			})
			.then(() => {
				// todo - refactor users collection?
					// use autogenerated ids?
					// lookup by email or keep a ref cached somewhere?
				firestore.collection('users').doc(firebase.auth().currentUser.uid).get()
					.then(userSnapshot => {
						// add contact email and ref to outgoing invitations sub-col of current user
						userSnapshot.ref.collection('outgoing_invitations').doc()
							.set({email: contactEmail, contactRef: contactSnapshot.ref})
							.catch(err => console.error('Error adding outgoingInvitation: ', err));

						// add current user ref to incoming invitations sub-col of contact
						contactSnapshot.ref.collection('incoming_invitations').doc()
							.set({userRef: userSnapshot.ref})
							.catch(err => console.error('Error adding incomingInvitation: ', err));
					})
					.catch(err => console.error('Error getting current user: ', err));
			});
	}

	addContact(e) {
		e.preventDefault();
		const nameField = document.querySelector('#name-field');

		firestore.collection('users/' + firebase.auth().currentUser.uid + '/contacts').doc()
			.set({ name: nameField.value })
			.catch(err => console.error('Error adding contact: ', err));

		nameField.value = null;
	}

	render({ contactStore }) {
		return (
			<div class={`${style.contactsList} page`}>
				<List avatar-list>
					{contactStore.contacts && contactStore.contacts.map(contact => (
						<List.Item>
							<List.ItemGraphic>perm_identity</List.ItemGraphic>
							<List.TextContainer>{contact.name}</List.TextContainer>
						</List.Item>
					))}
					<List.Item onClick={()=>{this.oldDialog.MDComponent.show();}}>
						<List.ItemGraphic>add_circle_outline</List.ItemGraphic>
						<List.TextContainer>Add a Contact</List.TextContainer>
					</List.Item>
					<List.Item onClick={()=>{this.newDialog.MDComponent.show();}}>
						<List.ItemGraphic>add_circle_outline</List.ItemGraphic>
						<List.TextContainer>Invite a Contact</List.TextContainer>
					</List.Item>
				</List>

				<Dialog ref={el => { this.oldDialog = el; }} onAccept={this.addContact.bind(this)}>
					<Dialog.Header>Add a Contact</Dialog.Header>
					<Dialog.Body>
						<TextField label="Name" outlined id="name-field"/>
					</Dialog.Body>
					<Dialog.Footer>
						<Dialog.FooterButton accept={true}>Save</Dialog.FooterButton>
					</Dialog.Footer>
				</Dialog>

				<Dialog ref={el => { this.newDialog = el; }} onAccept={this.inviteContact.bind(this)}>
					<Dialog.Header>Invite a Contact</Dialog.Header>
					<Dialog.Body>
						<TextField label="Email" outlined id="email-field"/>
					</Dialog.Body>
					<Dialog.Footer>
						<Dialog.FooterButton accept={true}>Save</Dialog.FooterButton>
					</Dialog.Footer>
				</Dialog>
			</div>
		);
	}
}
