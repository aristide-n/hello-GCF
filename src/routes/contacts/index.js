import { Component } from 'preact';
import { observer } from 'preact-mobx';
import List from 'preact-material-components/List';
import Dialog from 'preact-material-components/Dialog';
import TextField from 'preact-material-components/TextField';
import Button from 'preact-material-components/Button';
import Typography from 'preact-material-components/Typography';
import LayoutGrid from 'preact-material-components/LayoutGrid';
import 'preact-material-components/TextField/style.css';
import 'preact-material-components/List/style.css';
import 'preact-material-components/Button/style.css';
import 'preact-material-components/Dialog/style.css';
import 'preact-material-components/Button/style.css';
import 'preact-material-components/Typography/style.css';
import 'preact-material-components/LayoutGrid/style.css';
import style from './style.css';
import firebase, { firestore } from '../../state/firebase';

@observer
export default class ContactsList extends Component {

	inviteContact(e) {
		e.preventDefault();
		const contactPhoneNum = document.querySelector('#phonenum-field').value;
		const contactNickname = document.querySelector('#name-field').value;
		document.querySelector('#phonenum-field').value = null;
		document.querySelector('#name-field').value = null;


		// todo - maybe use transaction(s) somewhere in here?
		// check if this contact has already been invited or added,
		// todo - check in a cached list of phonenums in state/ later
		Promise.all([
			firestore.doc('users/' + firebase.auth().currentUser.uid).get()
				.then(snapshot => {
					// todo: validate phoneNum more thoroughly?
					if (snapshot.data().phoneNumber === contactPhoneNum) {
						return Promise.reject("can't invite yourself silly!");
					}
				}),
			firestore.collection('users/' + firebase.auth().currentUser.uid + '/outgoing_invitations')
				.where('phoneNumber', '==', contactPhoneNum)
				.get()
				.then(snapshot => {
						if (!snapshot.empty) {
							return Promise.reject("contact has already been invited");
						}
					}
				),
			firestore.collection('users/' + firebase.auth().currentUser.uid + '/contacts')
				.where('phoneNumber', '==', contactPhoneNum)
				.get()
				.then(snapshot => {
						if (!snapshot.empty) {
							return Promise.reject("contact has already been added");
						}
					}
				)
		]).then(_ => this.inviteContactHelper(contactPhoneNum, contactNickname));
	}

	inviteContactHelper(contactPhoneNum, contactNickname) {
		let contactSnapshot;

		// todo - maybe use transaction(s) somewhere in here?
		// query firestore for user with contactPhoneNum
		firestore.collection('users').where('phoneNumber', '==', contactPhoneNum)
			.get()
			.then(snapshot => {
					if(!snapshot.empty) {
						contactSnapshot = snapshot.docs[0];
						console.log('user_: ', contactSnapshot);
					}
				}
			)
			.then(() => {
				// if no such user, lookup phonenum in future_users
				if(!contactSnapshot) {
					return firestore.collection('future_users').where('phoneNumber', '==', contactPhoneNum)
						.get()
						.then(
							snapshot => {
								if(!snapshot.empty) {
									contactSnapshot = snapshot.docs[0];
									console.log('future_user_: ', contactSnapshot);
								}
							}
						);
				}
			})
			.then(() => {
				// if no such future_user, create future_user doc
				if(!contactSnapshot) {
					return firestore.collection('future_users').doc().get()
						.then(futureUserSnapshot => {
							contactSnapshot = futureUserSnapshot;
							futureUserSnapshot.ref.set({phoneNumber: contactPhoneNum, nickName: contactNickname});
						})
						.catch(err => {
							console.error('Error adding future_user: ', err);
							throw err;
							// todo - this is presumably the type of thing a transaction would be useful for
						});
				}
			})
			.then(() => {
				// todo - refactor users collection?
					// use autogenerated ids?
					// lookup by phonenum or keep a ref cached somewhere?
				const currentUserRef = firestore.collection('users').doc(firebase.auth().currentUser.uid);
				// add contact phonenum and ref to outgoing invitations sub-col of current user
				currentUserRef.collection('outgoing_invitations').doc()
					.set({phoneNumber: contactPhoneNum, nickName: contactNickname, contactRef: contactSnapshot.ref})
					.catch(err => console.error('Error adding outgoingInvitation: ', err));

				// add current user ref to incoming invitations sub-col of contact
				contactSnapshot.ref.collection('incoming_invitations').doc()
					.set({userRef: currentUserRef})
					.catch(err => console.error('Error adding incomingInvitation: ', err));
			});
	}

	acceptInvitation(fromUserRef) {
		console.log('accept ', fromUserRef);
		const currentUserRef = firestore.collection('users').doc(firebase.auth().currentUser.uid);

		// create contact doc
		fromUserRef.get()
			.then(fromUserSnap => {
				currentUserRef.collection('contacts').doc()
					.set({userRef: fromUserRef, email: fromUserSnap.data().email,
						phoneNumber: fromUserSnap.data().phoneNumber, isAvailable: fromUserSnap.data().isAvailable})
					.catch(err => console.error('Error adding contact: ', err));
			});

		// delete incoming invitations doc
		this.deleteIncomingInvitationDoc(fromUserRef, currentUserRef);
		// set isAccepted flag to true in fromUser's outgoing invitation doc
		fromUserRef.collection('outgoing_invitations').where('contactRef', '==', currentUserRef).get()
			.then(snapshot => snapshot.docs[0].ref.update({isAccepted: true}))
			.catch(err => console.error('Error updating isAccepted in outgoing_invitations doc: ', err));
	}

	declineInvitation(fromUserRef) {
		console.log('decline ', fromUserRef);
		const currentUserRef = firestore.collection('users').doc(firebase.auth().currentUser.uid);
		this.deleteIncomingInvitationDoc(fromUserRef, currentUserRef);
		// set isDeclined flag to true in fromUser's outgoing invitation doc
		fromUserRef.collection('outgoing_invitations').where('contactRef', '==', currentUserRef).get()
			.then(snapshot => snapshot.docs[0].ref.update({isDeclined: true}))
			.catch(err => console.error('Error updating isDeclined in outgoing_invitations doc: ', err));
	}

	deleteIncomingInvitationDoc(fromUserRef, currentUserRef) {
		currentUserRef.collection('incoming_invitations').where('userRef', '==', fromUserRef).get()
			.then(snapshot => snapshot.docs[0].ref.delete())
			.catch(err => console.error('Error deleting incoming_invitations doc: ', err));
	}

	render({ contactStore }) {
		return (
			<div class={`${style.contactsList} page`}>
				<List avatar-list>
					{contactStore.incomingInvitations.size > 0 &&
					<List.Item>
						<List.TextContainer>
							<Typography overline>
								INVITATIONS ({contactStore.incomingInvitations.size})
							</Typography>
						</List.TextContainer>
					</List.Item>
					}
					{contactStore.incomingInvitations.size > 0 &&
						Array.from(contactStore.incomingInvitations.values()).map(fromUser => (
							<List.Item>
								<List.ItemGraphic>perm_identity</List.ItemGraphic>
								<LayoutGrid.Inner>
									<LayoutGrid.Cell cols="4">{fromUser.fromUserName}</LayoutGrid.Cell>
									<LayoutGrid.Cell cols="4">{fromUser.fromUserPhoneNumber}</LayoutGrid.Cell>
									<LayoutGrid.Cell cols="4">{fromUser.fromUserEmail}</LayoutGrid.Cell>
								</LayoutGrid.Inner>
								{/*<List.TextContainer>{fromUser.fromUserName}</List.TextContainer>*/}
								{/*<List.TextContainer>{fromUser.fromUserPhoneNumber}</List.TextContainer>*/}
								<List.ItemMeta>
									<div className={`${style.buttons}`}>
										<Button dense onClick={this.declineInvitation.bind(this, fromUser.fromUserRef)}>
											Decline
										</Button>
										<Button outlined dense onClick={this.acceptInvitation.bind(this,
											fromUser.fromUserRef)}>
											Accept
										</Button>
									</div>
								</List.ItemMeta>
							</List.Item>
						))
					}

					{contactStore.contacts.size > 0 &&
					<List.Item>
						<List.TextContainer>
							<Typography overline>
								CONTACTS ({contactStore.contacts.size})
							</Typography>
						</List.TextContainer>
					</List.Item>
					}
					{contactStore.contacts.size > 0 &&
					Array.from(contactStore.contacts.values()).map(contact => (
						// color options #dcedc8 #e8f5e9
						<List.Item style={{ background: contact.isAvailable ? '#e8f5e9' : '#fafafa' }}>
							<List.ItemGraphic>perm_identity</List.ItemGraphic>
							<LayoutGrid.Inner>
								<LayoutGrid.Cell cols="4">{contact.name}</LayoutGrid.Cell>
								<LayoutGrid.Cell cols="4">{contact.phoneNumber}</LayoutGrid.Cell>
								<LayoutGrid.Cell cols="4">{contact.email}</LayoutGrid.Cell>
							</LayoutGrid.Inner>
						</List.Item>
					))
					}

					<List.Item onClick={()=>{this.inviteDialog.MDComponent.show();}}>
						<List.ItemGraphic>add_circle</List.ItemGraphic>
						<List.TextContainer>Send an Invitation</List.TextContainer>
					</List.Item>

					{contactStore.outgoingInvitations.size > 0 &&
						<List.Item>
							<List.TextContainer>
								<Typography overline>
									INVITATIONS YOU SENT ({contactStore.outgoingInvitations.size})
								</Typography>
							</List.TextContainer>
						</List.Item>
					}
					{contactStore.outgoingInvitations.size > 0 &&
						Array.from(contactStore.outgoingInvitations.values()).map(invitation => (
							<List.Item>
								<List.ItemGraphic>perm_identity</List.ItemGraphic>

								<LayoutGrid.Inner>
									<LayoutGrid.Cell cols="4">{invitation.nickName}</LayoutGrid.Cell>
									<LayoutGrid.Cell cols="4">{invitation.phoneNumber}</LayoutGrid.Cell>
								</LayoutGrid.Inner>
							</List.Item>
						))
					}
				</List>

				<Dialog ref={el => { this.inviteDialog = el; }} onAccept={this.inviteContact.bind(this)}>
					<Dialog.Header>Invite a Contact</Dialog.Header>
					<Dialog.Body>
						<TextField label="Phone number" outlined id="phonenum-field"/>
						<TextField label="Name (optional)" outlined id="name-field"/>
					</Dialog.Body>
					<Dialog.Footer>
						<Dialog.FooterButton accept={true}>Save</Dialog.FooterButton>
					</Dialog.Footer>
				</Dialog>
			</div>
		);
	}
}
